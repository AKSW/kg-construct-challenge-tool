#!/usr/bin/env python3

import os
import sys
import argparse
import subprocess
import atexit
from datetime import datetime
from signal import signal, SIGINT
from time import sleep
from zipfile import ZipFile
from bench_executor import Executor, Manager

VERSION = '0.1.0'
EXIT_CODE_UNKNOWN_COMMAND = -1
EXIT_CODE_NO_CASES = -2
EXIT_CODE_FAILED_CASE = -3
EXIT_CODE_INTERRUPTED = -4
EXIT_CODE_SELINUX = -5
EXIT_CODE_EVEN_RUNS = -6
EXIT_CODE_INTERRUPTED = -7

stop = False
manager = Manager()

@atexit.register
def _clean():
    if len(manager.list_all()) > 0:
        print('Cleaning up before exiting...')
        manager.stop_all()

def _format_progress(index: int, number_of_cases: int, start_time: datetime):
    # Percentage completed cases
    percentage = f'{int(100.0 * (index)/number_of_cases)}%'

    # Time spent since started
    delta = datetime.now() - start_time
    hours = int(delta.total_seconds() / 3600)
    minutes = int((delta.total_seconds() - hours * 3600) / 60)
    seconds = int(delta.total_seconds() - hours * 3600 - minutes * 60)

    if minutes == 0 and hours == 0:
        timestamp = f'{seconds : >5}s'
    elif hours == 0:
        timestamp = f'{minutes : >2}m{seconds : >2}s'
    else:
        timestamp = f'{hours : >2}h{minutes : >2}m'

    # Format progress
    return f'[{percentage : >4} {timestamp : >6}]'

def signal_handler_interrupt(signum, frame):
    global stop

    if not stop:
        print('Waiting for case to finish before exiting...')
        stop = True
        print('Pressing again CTRL+C will exit immediately!')
    else:
        if len(manager.list_all()) > 0:
            print('Cleaning up before exiting...')
            manager.stop_all()
        sys.exit(EXIT_CODE_INTERRUPTED)

def print_cases(executor: Executor):
    cases = e.list()

    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    print(f'Discovering {len(cases)} cases:')
    for index, case in enumerate(cases):
        name = case['data']['name']
        number_of_steps = f'[ {len(case["data"]["steps"])} steps ]'
        print(f'{index+1 : >4}. {name : <85} {number_of_steps: >11}')

def execute_cases(executor: Executor, interval: float, runs: int,
                  fail_fast: bool, wait_for_user: bool):
    global stop
    failures = []

    signal(SIGINT, signal_handler_interrupt)

    cases = e.list()
    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    if wait_for_user:
        runs = 1

    print(f'Executing {len(cases)} cases:')
    start_time = datetime.now()
    for index, case in enumerate(cases):
        data = case['data']
        directory = case['directory']
        results_directory = os.path.join(directory, 'results')
        checkpoint_file = os.path.join(directory, '.done')

        progress = _format_progress(index, len(cases), start_time)
        print(f'{index+1 : >4}. {data["name"][0:62] : <83} {progress : <13}')

        # Skip cases which are already done
        all_runs_complete = True
        start_run = 1
        for i in range(1, runs+1):
            run_checkpoint_file = os.path.join(results_directory,
                                               f'run_{i}', '.done')
            start_run = i
            if not os.path.exists(run_checkpoint_file):
                all_runs_complete = False
                break

        if os.path.exists(checkpoint_file) and all_runs_complete:
            print(f'        ⏩ SKIPPED CASE')
            continue

        # Execute case with all runs
        for i in range(start_run, runs+1):
            run_checkpoint_file = os.path.join(results_directory,
                                               f'run_{i}', '.done')

            print(f'      ==> Run #{i} <==')
            if os.path.exists(run_checkpoint_file):
                print(f'        ⏩ SKIPPED RUN')
                continue

            success, diff = e.run(case, interval, i, wait_for_user, i == runs)

            if not success:
                if data['name'] not in failures:
                    failures.append(data['name'])
                if fail_fast:
                    break

            if stop:
                sys.exit(EXIT_CODE_INTERRUPTED)

    # Exit with error code when we have a failed case
    if failures:
        print(f'{len(failures)}/{len(cases)} cases failed to execute:',
              file=sys.stderr)
        for index, f in enumerate(failures):
            print(f'{index+1 : >4}. {f : <76}')
        sys.exit(EXIT_CODE_FAILED_CASE)
    else:
        msg = f'{len(cases)} executed succesfully'
        progress = _format_progress(len(cases), len(cases), start_time)
        print(f'{msg : <69} {progress : <13}')


def clean_cases(executor: Executor):
    cases = e.list()

    for case in cases:
        e.clean(case)
    print(f'Cleaned {len(cases)} cases')

def generate_statistics(executor: Executor):
    cases = e.list()
    failures = []

    print('Generating statistics for cases:')

    for case in cases:
        print(f"\t{case['data']['name']}")

        # Skip already generated stats
        if os.path.exists(os.path.join(case['directory'], 'results',
                                       'aggregated.json')):
            continue

        success = e.stats(case)
        if not success:
            name = case['data']['name']
            if name not in failures:
                failures.append(name)
            print(f'Could not generate statistics for case "{name}"',
                  file=sys.stderr)

    if failures:
        print(f'{len(failures)}/{len(cases)} cases failed to execute:',
              file=sys.stderr)
        for index, f in enumerate(failures):
            print(f'{index+1 : >4}. {f : <76}')
        sys.exit(EXIT_CODE_FAILED_CASE)

    print(f'Generated statistics for {len(cases)} cases')

    archive_name = os.path.join(e.main_directory, 'aggregated_results.zip')
    with ZipFile(archive_name, 'w') as archive:
        for case in cases:
            directory = case['directory']
            aggregated_file = os.path.join(directory, 'results', 'aggregated.json')
            if os.path.exists(aggregated_file):
                archive.write(aggregated_file)

    print(f'Generated statistics archive')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Copyright by (c) Dylan Van Assche (2022), available under GPLv3 license',
                                     epilog='Please cite our paper if you make use of this tool')
    parser.add_argument('--version', action='version',
                        version=f'{parser.prog} {VERSION}')
    parser.add_argument(dest='command',
                        help='Command to execute, available commands: "list", "run"',
                        type=str)
    parser.add_argument('--root', dest='main_directory', default='.',
                        help='Root directory of all cases to execute, defaults to the current working directory',
                        type=str)
    parser.add_argument('--runs', dest='number_of_runs', default=3,
                        help='Number of runs to execute a case. The value must be uneven for generating stats. Default 3 runs',
                        type=int)
    parser.add_argument('--interval', dest='interval', default=0.1,
                        help='Measurement sample interval for metrics, default 0.1s',
                        type=float)
    parser.add_argument('--verbose', dest='verbose',
                        help='Turn on verbose output', action='store_true')
    parser.add_argument('--fail-fast', dest='fail_fast',
                        help='Immediately exit when a case fails', action='store_true')
    parser.add_argument('--wait-for-user', dest='wait_for_user',
                        help='Show a prompt when a step is executed before '
                             'going to the next one', action='store_true')
    args = parser.parse_args()

    # Resolve path
    main_directory = os.path.expanduser(args.main_directory)
    main_directory = os.path.expandvars(main_directory)

    if args.verbose:
        print(f'{parser.prog} {VERSION}')
        print(f'Command: {args.command}')
        print(f'Root directory: {main_directory}')
        print(f'Verbose enabled: {args.verbose}')
        print(f'Fail fast enabled: {args.fail_fast}')
        print(f'Number of runs: {args.number_of_runs}')
        print(f'Measurement sample interval: {args.interval}s')
        print(f'Wait for user after case: {args.wait_for_user}')

    if args.interval % 2 == 0:
        print('Number of runs must be uneven for generating statistics',
              file=sys.stderr)
        sys.exit(EXIT_CODE_EVEN_RUNS)

    # SELinux causes weird permission denied issues, warn users
    if 'run' in args.command or 'clean' in args.command:
        try:
            response = subprocess.check_output('getenforce')
            if response.decode().strip() != 'Permissive':
                print('SELinux must be set to "permissive" to allow containers '
                      'accessing files in mounted directories', file=sys.stderr)
                sys.exit(EXIT_CODE_SELINUX)
        except subprocess.CalledProcessError:
            pass
        except FileNotFoundError:
            pass

    e = Executor(main_directory, verbose=args.verbose, cli=True)

    if args.command == 'list':
        print_cases(e)
    elif args.command == 'run':
        execute_cases(e, args.interval, args.number_of_runs, args.fail_fast,
                      args.wait_for_user)
    elif args.command == 'clean':
        clean_cases(e)
    elif args.command == 'stats':
        generate_statistics(e)
    else:
        print(f'Unknown command: {args.command}', file=sys.stderr)
        sys.exit(EXIT_CODE_UNKNOWN_COMMAND)
