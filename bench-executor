#!/usr/bin/env python3

import os
import sys
import argparse
from signal import signal, SIGINT
from bench_executor import Executor

VERSION = '0.1.0'
EXIT_CODE_UNKNOWN_COMMAND = -1
EXIT_CODE_NO_CASES = -2
EXIT_CODE_FAILED_CASE = -3
EXIT_CODE_INTERRUPTED = -4
EXIT_CODE_SELINUX = -5
stop = False

def signal_handler(signum, frame):
    global stop

    print('Waiting for case to finish before exiting...')
    stop = True

def print_cases(executor: Executor):
    cases = e.list()

    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    print(f'Discovering {len(cases)} cases:')
    for index, case in enumerate(cases):
        name = case['data']['name']
        number_of_steps = f'[ {len(case["data"]["steps"])} steps ]'
        print(f'{index+1 : >4}. {name : <65} {number_of_steps: >11}')

def execute_cases(executor: Executor, interval: float, runs: int,
                  fail_fast: bool):
    global stop
    failures = []

    signal(SIGINT, signal_handler)

    cases = e.list()
    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    print(f'Executing {len(cases)} cases:')
    for index, case in enumerate(cases):
        data = case['data']
        p = int(100.0 * (index + 1)/len(cases))
        percentage = f'[ {p : >3}% ]'

        print(f'{index+1 : >4}. {data["name"] : <67} {percentage : <9}')
        for i in range(1, runs+1):
            print(f'      ==> Run #{i} <==')
            success, diff = e.run(case, interval, i, i == (runs+1))

            if not success:
                failures.append(data['name'])
                if fail_fast:
                    break

            if stop:
                sys.exit(EXIT_CODE_INTERRUPTED)

    # Exit with error code when we have a failed case
    if failures:
        print(f'{len(failures)}/{len(cases)} cases failed to execute:',
              file=sys.stderr)
        for index, f in enumerate(failures):
            print(f'{index+1 : >4}. {f : <76}')
        sys.exit(EXIT_CODE_FAILED_CASE)

def clean_cases(executor: Executor):
    cases = e.list()

    for case in cases:
        e.clean(case)
    print(f'Cleaned {len(cases)} cases')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Copyright by (c) Dylan Van Assche (2022), available under GPLv3 license',
                                     epilog='Please cite our paper if you make use of this tool')
    parser.add_argument('--version', action='version',
                        version=f'{parser.prog} {VERSION}')
    parser.add_argument(dest='command',
                        help='Command to execute, available commands: "list", "run"',
                        type=str)
    parser.add_argument('--root', dest='main_directory', default='.',
                        help='Root directory of all cases to execute, defaults to the current working directory',
                        type=str)
    parser.add_argument('--runs', dest='number_of_runs', default=3,
                        help='Number of runs to execute a case. Default 3 runs',
                        type=int)
    parser.add_argument('--interval', dest='interval', default=1.0,
                        help='Measurement sample interval for metrics, default 1s',
                        type=float)
    parser.add_argument('--verbose', dest='verbose',
                        help='Turn on verbose output', action='store_true')
    parser.add_argument('--fail-fast', dest='fail_fast',
                        help='Immediately exit when a case fails', action='store_true')
    args = parser.parse_args()

    if args.verbose:
        print(f'{parser.prog} {VERSION}')
        print(f'Command: {args.command}')
        print(f'Root directory: {args.main_directory}')
        print(f'Verbose enabled: {args.verbose}')
        print(f'Fail fast enabled: {args.fail_fast}')
        print(f'Number of runs: {args.number_of_runs}')
        print(f'Measurement sample interval: {args.interval}s')

    # SELinux causes weird permission denied issues, warn users
    try:
        response = subprocess.check_output('getenforce')
        if response.decode().strip() != 'Permissive':
            print('SELinux must be set to "permissive" to allow containers '
                  'accessing files in mounted directories', file=sys.stderr)
            sys.exit(EXIT_CODE_SELINUX)
    except subprocess.CalledProcessError:
        pass

    e = Executor(args.main_directory, verbose=args.verbose, cli=True)

    if args.command == 'list':
        print_cases(e)
    elif args.command == 'run':
        execute_cases(e, args.interval, args.number_of_runs, args.fail_fast)
    elif args.command == 'clean':
        clean_cases(e)
    else:
        print(f'Unknown command: {args.command}', file=sys.stderr)
        sys.exit(EXIT_CODE_UNKNOWN_COMMAND)
