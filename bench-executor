#!/usr/bin/env python3

import os
import sys
import argparse
import subprocess
import atexit
from datetime import datetime
from signal import signal, SIGINT
from time import sleep
from bench_executor import Executor, Manager

VERSION = '0.1.0'
EXIT_CODE_UNKNOWN_COMMAND = -1
EXIT_CODE_NO_CASES = -2
EXIT_CODE_FAILED_CASE = -3
EXIT_CODE_INTERRUPTED = -4
EXIT_CODE_SELINUX = -5
EXIT_CODE_EVEN_RUNS = -6

stop = False
manager = Manager()

@atexit.register
def _clean():
    if len(manager.list_all()) > 0:
        print('Cleaning up before exiting...')
        manager.stop_all()

def signal_handler(signum, frame):
    global stop

    print('Waiting for case to finish before exiting...')
    stop = True

def print_cases(executor: Executor):
    cases = e.list()

    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    print(f'Discovering {len(cases)} cases:')
    for index, case in enumerate(cases):
        name = case['data']['name']
        number_of_steps = f'[ {len(case["data"]["steps"])} steps ]'
        print(f'{index+1 : >4}. {name : <65} {number_of_steps: >11}')

def execute_cases(executor: Executor, interval: float, runs: int,
                  fail_fast: bool):
    global stop
    failures = []

    signal(SIGINT, signal_handler)

    cases = e.list()
    if not cases:
        print('No cases discovered!')
        sys.exit(EXIT_CODE_NO_CASES)

    print(f'Executing {len(cases)} cases:')
    start_time = datetime.now()
    for index, case in enumerate(cases):
        data = case['data']

        # Percentage completed cases
        percentage = f'{int(100.0 * (index)/len(cases))}%'

        # Time spent since started
        delta = datetime.now() - start_time
        hours = int(delta.total_seconds() / 3600)
        minutes = int((delta.total_seconds() - hours * 3600) / 60)
        seconds = int(delta.total_seconds() - hours * 3600 - minutes * 60)

        if minutes == 0:
            timestamp = f'{seconds : >5}s'
        elif hours == 0:
            timestamp = f'{minutes : >2}m{seconds : >2}s'
        else:
            timestamp = f'{hours : >2}h{minutes : >2}m'

        # Log progress
        progress = f'[{percentage : >4} {timestamp : >6}]'

        print(f'{index+1 : >4}. {data["name"] : <63} {progress : <13}')
        for i in range(1, runs+1):
            print(f'      ==> Run #{i} <==')
            success, diff = e.run(case, interval, i, i == runs)

            if not success:
                if data['name'] not in failures:
                    failures.append(data['name'])
                if fail_fast:
                    break

            if stop:
                sys.exit(EXIT_CODE_INTERRUPTED)

    # Exit with error code when we have a failed case
    if failures:
        print(f'{len(failures)}/{len(cases)} cases failed to execute:',
              file=sys.stderr)
        for index, f in enumerate(failures):
            print(f'{index+1 : >4}. {f : <76}')
        sys.exit(EXIT_CODE_FAILED_CASE)

def clean_cases(executor: Executor):
    cases = e.list()

    for case in cases:
        e.clean(case)
    print(f'Cleaned {len(cases)} cases')

def generate_statistics(executor: Executor):
    cases = e.list()

    for case in cases:
        success = e.stats(case)
        if not success:
            name = case['data']['name']
            print(f'Could not generate statistics for case "{name}"',
                  file=sys.stderr)
            sys.exit(EXIT_CODE_FAILED_CASE)

    print(f'Generated statistics for {len(cases)} cases')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Copyright by (c) Dylan Van Assche (2022), available under GPLv3 license',
                                     epilog='Please cite our paper if you make use of this tool')
    parser.add_argument('--version', action='version',
                        version=f'{parser.prog} {VERSION}')
    parser.add_argument(dest='command',
                        help='Command to execute, available commands: "list", "run"',
                        type=str)
    parser.add_argument('--root', dest='main_directory', default='.',
                        help='Root directory of all cases to execute, defaults to the current working directory',
                        type=str)
    parser.add_argument('--runs', dest='number_of_runs', default=3,
                        help='Number of runs to execute a case. The value must be uneven for generating stats. Default 3 runs',
                        type=int)
    parser.add_argument('--interval', dest='interval', default=0.1,
                        help='Measurement sample interval for metrics, default 0.1s',
                        type=float)
    parser.add_argument('--verbose', dest='verbose',
                        help='Turn on verbose output', action='store_true')
    parser.add_argument('--fail-fast', dest='fail_fast',
                        help='Immediately exit when a case fails', action='store_true')
    args = parser.parse_args()

    if args.verbose:
        print(f'{parser.prog} {VERSION}')
        print(f'Command: {args.command}')
        print(f'Root directory: {args.main_directory}')
        print(f'Verbose enabled: {args.verbose}')
        print(f'Fail fast enabled: {args.fail_fast}')
        print(f'Number of runs: {args.number_of_runs}')
        print(f'Measurement sample interval: {args.interval}s')

    if args.interval % 2 == 0:
        print('Number of runs must be uneven for generating statistics',
              file=sys.stderr)
        sys.exit(EXIT_CODE_EVEN_RUNS)

    # SELinux causes weird permission denied issues, warn users
    try:
        response = subprocess.check_output('getenforce')
        if response.decode().strip() != 'Permissive':
            print('SELinux must be set to "permissive" to allow containers '
                  'accessing files in mounted directories', file=sys.stderr)
            sys.exit(EXIT_CODE_SELINUX)
    except subprocess.CalledProcessError:
        pass

    e = Executor(args.main_directory, verbose=args.verbose, cli=True)

    if args.command == 'list':
        print_cases(e)
    elif args.command == 'run':
        execute_cases(e, args.interval, args.number_of_runs, args.fail_fast)
    elif args.command == 'clean':
        clean_cases(e)
    elif args.command == 'stats':
        generate_statistics(e)
    else:
        print(f'Unknown command: {args.command}', file=sys.stderr)
        sys.exit(EXIT_CODE_UNKNOWN_COMMAND)
